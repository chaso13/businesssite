import {
  require_prop_types
} from "./chunk-KK5XZ6VE.js";
import "./chunk-FH2XTGEL.js";
import {
  require_react
} from "./chunk-ZOIWZPCO.js";
import {
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/react-cache-buster/dist/index.modern.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/compare-versions/index.mjs
function compareVersions(v1, v2) {
  const n1 = validateAndParse(v1);
  const n2 = validateAndParse(v2);
  const p1 = n1.pop();
  const p2 = n2.pop();
  const r = compareSegments(n1, n2);
  if (r !== 0)
    return r;
  if (p1 && p2) {
    return compareSegments(p1.split("."), p2.split("."));
  } else if (p1 || p2) {
    return p1 ? -1 : 1;
  }
  return 0;
}
var validate = (v) => typeof v === "string" && /^[v\d]/.test(v) && semver.test(v);
var compare = (v1, v2, operator) => {
  assertValidOperator(operator);
  const res = compareVersions(v1, v2);
  return operatorResMap[operator].includes(res);
};
var satisfies = (v, r) => {
  const m = r.match(/^([<>=~^]+)/);
  const op = m ? m[1] : "=";
  if (op !== "^" && op !== "~")
    return compare(v, r, op);
  const [v1, v2, v3] = validateAndParse(v);
  const [r1, r2, r3] = validateAndParse(r);
  if (compareStrings(v1, r1) !== 0)
    return false;
  if (op === "^") {
    return compareSegments([v2, v3], [r2, r3]) >= 0;
  }
  if (compareStrings(v2, r2) !== 0)
    return false;
  return compareStrings(v3, r3) >= 0;
};
compareVersions.validate = validate;
compareVersions.compare = compare;
compareVersions.satisfies = satisfies;
var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
var validateAndParse = (v) => {
  if (typeof v !== "string") {
    throw new TypeError("Invalid argument expected string");
  }
  const match = v.match(semver);
  if (!match) {
    throw new Error(`Invalid argument not valid semver ('${v}' received)`);
  }
  match.shift();
  return match;
};
var isWildcard = (s) => s === "*" || s === "x" || s === "X";
var tryParse = (v) => {
  const n = parseInt(v, 10);
  return isNaN(n) ? v : n;
};
var forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
var compareStrings = (a, b) => {
  if (isWildcard(a) || isWildcard(b))
    return 0;
  const [ap, bp] = forceType(tryParse(a), tryParse(b));
  if (ap > bp)
    return 1;
  if (ap < bp)
    return -1;
  return 0;
};
var compareSegments = (a, b) => {
  for (let i = 0; i < Math.max(a.length, b.length); i++) {
    const r = compareStrings(a[i] || 0, b[i] || 0);
    if (r !== 0)
      return r;
  }
  return 0;
};
var operatorResMap = {
  ">": [1],
  ">=": [0, 1],
  "=": [0],
  "<=": [-1, 0],
  "<": [-1]
};
var allowedOperators = Object.keys(operatorResMap);
var assertValidOperator = (op) => {
  if (typeof op !== "string") {
    throw new TypeError(
      `Invalid operator type, expected string but got ${typeof op}`
    );
  }
  if (allowedOperators.indexOf(op) === -1) {
    throw new Error(
      `Invalid operator, expected one of ${allowedOperators.join("|")}`
    );
  }
};

// node_modules/react-cache-buster/dist/index.modern.js
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
var CacheBusterContext = (0, import_react.createContext)({
  checkCacheStatus: function checkCacheStatus() {
  }
});
function CacheBuster(_ref) {
  var _ref$children = _ref.children, children = _ref$children === void 0 ? null : _ref$children, currentVersion = _ref.currentVersion, _ref$isEnabled = _ref.isEnabled, isEnabled = _ref$isEnabled === void 0 ? false : _ref$isEnabled, _ref$isVerboseMode = _ref.isVerboseMode, isVerboseMode = _ref$isVerboseMode === void 0 ? false : _ref$isVerboseMode, _ref$loadingComponent = _ref.loadingComponent, loadingComponent = _ref$loadingComponent === void 0 ? null : _ref$loadingComponent, _ref$metaFileDirector = _ref.metaFileDirectory, metaFileDirectory = _ref$metaFileDirector === void 0 ? null : _ref$metaFileDirector, _ref$reloadOnDowngrad = _ref.reloadOnDowngrade, reloadOnDowngrade = _ref$reloadOnDowngrad === void 0 ? false : _ref$reloadOnDowngrad, onCacheClear = _ref.onCacheClear;
  var _useState = (0, import_react.useState)({
    loading: true,
    isLatestVersion: false
  }), cacheStatus = _useState[0], setCacheStatus = _useState[1];
  var log = function log2(message, isError) {
    isVerboseMode && (isError ? console.error(message) : console.log(message));
  };
  (0, import_react.useEffect)(function() {
    isEnabled ? checkCacheStatus2() : log("React Cache Buster is disabled.");
  }, []);
  var getMetaFileDirectory = function getMetaFileDirectory2() {
    return !metaFileDirectory || metaFileDirectory === "." ? "" : metaFileDirectory;
  };
  var checkCacheStatus2 = (0, import_react.useCallback)(function() {
    try {
      var _temp2 = _catch(function() {
        return Promise.resolve(fetch(getMetaFileDirectory() + "/meta.json")).then(function(res) {
          return Promise.resolve(res.json()).then(function(_ref2) {
            var metaVersion = _ref2.version;
            var shouldForceRefresh = isThereNewVersion(metaVersion, currentVersion);
            if (shouldForceRefresh) {
              log("There is a new version (v" + metaVersion + "). Should force refresh.");
              setCacheStatus({
                loading: false,
                isLatestVersion: false
              });
            } else {
              log("There is no new version. No cache refresh needed.");
              setCacheStatus({
                loading: false,
                isLatestVersion: true
              });
            }
          });
        });
      }, function(error) {
        log("An error occurred while checking cache status.", true);
        log(error, true);
        !isVerboseMode && setCacheStatus({
          loading: false,
          isLatestVersion: true
        });
      });
      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  }, [currentVersion, isVerboseMode, metaFileDirectory]);
  var isThereNewVersion = function isThereNewVersion2(metaVersion, currentVersion2) {
    if (reloadOnDowngrade) {
      return !compare(metaVersion, currentVersion2, "=");
    }
    return compare(metaVersion, currentVersion2, ">");
  };
  var refreshCacheAndReload = function refreshCacheAndReload2() {
    try {
      return Promise.resolve(_catch(function() {
        var _temp3 = function() {
          var _window;
          if ((_window = window) !== null && _window !== void 0 && _window.caches) {
            var _window2 = window, caches = _window2.caches;
            return Promise.resolve(caches.keys()).then(function(cacheNames) {
              var cacheDeletionPromises = cacheNames.map(function(n) {
                return caches["delete"](n);
              });
              return Promise.resolve(Promise.all(cacheDeletionPromises)).then(function() {
                log("The cache has been deleted.");
                window.location.reload(true);
              });
            });
          }
        }();
        if (_temp3 && _temp3.then)
          return _temp3.then(function() {
          });
      }, function(error) {
        log("An error occurred while deleting the cache.", true);
        log(error, true);
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  if (!isEnabled) {
    return children;
  } else {
    if (cacheStatus.loading) {
      return loadingComponent;
    }
    if (!cacheStatus.loading && !cacheStatus.isLatestVersion) {
      if (onCacheClear) {
        onCacheClear(refreshCacheAndReload);
      } else {
        refreshCacheAndReload();
      }
      return null;
    }
    return import_react.default.createElement(CacheBusterContext.Provider, {
      value: {
        checkCacheStatus: checkCacheStatus2
      }
    }, children);
  }
}
CacheBuster.propTypes = {
  children: import_prop_types.default.element.isRequired,
  currentVersion: import_prop_types.default.string.isRequired,
  isEnabled: import_prop_types.default.bool.isRequired,
  isVerboseMode: import_prop_types.default.bool,
  loadingComponent: import_prop_types.default.element,
  metaFileDirectory: import_prop_types.default.string,
  onCacheClear: import_prop_types.default.func
};
var useCacheBuster = function useCacheBuster2() {
  var context = (0, import_react.useContext)(CacheBusterContext);
  if (context === void 0 || context === null) {
    throw new Error("useCacheBuster must be used within a CacheBuster component.");
  }
  return context;
};
var index_modern_default = CacheBuster;
export {
  index_modern_default as default,
  useCacheBuster
};
//# sourceMappingURL=react-cache-buster.js.map
